"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[3489],{7950(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-3/chapter-3-nav2-humanoid-navigation","title":"Nav2 for Humanoid Navigation","description":"Learn about Navigation2 configuration for humanoid robots, focusing on path planning and navigation workflows adapted for bipedal locomotion.","source":"@site/docs/module-3/chapter-3-nav2-humanoid-navigation.md","sourceDirName":"module-3","slug":"/module-3/chapter-3-nav2-humanoid-navigation","permalink":"/docs/module-3/chapter-3-nav2-humanoid-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3/chapter-3-nav2-humanoid-navigation.md","tags":[{"inline":true,"label":"nav2","permalink":"/docs/tags/nav-2"},{"inline":true,"label":"humanoid-navigation","permalink":"/docs/tags/humanoid-navigation"},{"inline":true,"label":"path-planning","permalink":"/docs/tags/path-planning"},{"inline":true,"label":"bipedal-locomotion","permalink":"/docs/tags/bipedal-locomotion"},{"inline":true,"label":"gait-aware-navigation","permalink":"/docs/tags/gait-aware-navigation"},{"inline":true,"label":"robotics","permalink":"/docs/tags/robotics"}],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Nav2 for Humanoid Navigation","sidebar_position":3,"tags":["nav2","humanoid-navigation","path-planning","bipedal-locomotion","gait-aware-navigation","robotics"],"description":"Learn about Navigation2 configuration for humanoid robots, focusing on path planning and navigation workflows adapted for bipedal locomotion."},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS Integration","permalink":"/docs/module-3/chapter-2-isaac-ros-integration"},"next":{"title":"Introduction to Vision-Language-Action (VLA)","permalink":"/docs/module-4/intro"}}');var o=a(4848),t=a(8453);const r={title:"Nav2 for Humanoid Navigation",sidebar_position:3,tags:["nav2","humanoid-navigation","path-planning","bipedal-locomotion","gait-aware-navigation","robotics"],description:"Learn about Navigation2 configuration for humanoid robots, focusing on path planning and navigation workflows adapted for bipedal locomotion."},s="Nav2 for Humanoid Navigation",l={},c=[{value:"Overview of Nav2 for Humanoid Robots",id:"overview-of-nav2-for-humanoid-robots",level:2},{value:"Cross-Module Connections",id:"cross-module-connections",level:2},{value:"Key Differences from Wheeled Robot Navigation",id:"key-differences-from-wheeled-robot-navigation",level:2},{value:"Mobility Constraints",id:"mobility-constraints",level:3},{value:"Gait Patterns",id:"gait-patterns",level:3},{value:"Nav2 Architecture for Humanoid Robots",id:"nav2-architecture-for-humanoid-robots",level:2},{value:"Core Components",id:"core-components",level:3},{value:"1. Global Planner (Humanoid-Aware)",id:"1-global-planner-humanoid-aware",level:4},{value:"2. Local Planner (Balance-Constrained)",id:"2-local-planner-balance-constrained",level:4},{value:"3. Controller (Gait-Based)",id:"3-controller-gait-based",level:4},{value:"Humanoid-Specific Plugins",id:"humanoid-specific-plugins",level:3},{value:"Footstep Planner Plugin",id:"footstep-planner-plugin",level:4},{value:"Balance Constraint Plugin",id:"balance-constraint-plugin",level:4},{value:"Nav2 Configuration for Humanoid Navigation",id:"nav2-configuration-for-humanoid-navigation",level:2},{value:"Global Planner Configuration",id:"global-planner-configuration",level:3},{value:"Humanoid-Optimized Global Planner Parameters",id:"humanoid-optimized-global-planner-parameters",level:4},{value:"Local Planner Configuration",id:"local-planner-configuration",level:3},{value:"DWB (Dynamic Window Approach) for Humanoid Robots",id:"dwb-dynamic-window-approach-for-humanoid-robots",level:4},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Humanoid-Aware Costmaps",id:"humanoid-aware-costmaps",level:4},{value:"Practical Examples: Humanoid Navigation Scenarios",id:"practical-examples-humanoid-navigation-scenarios",level:2},{value:"Example 1: Basic Humanoid Navigation Setup",id:"example-1-basic-humanoid-navigation-setup",level:3},{value:"Example 2: Humanoid Footstep Planning Integration",id:"example-2-humanoid-footstep-planning-integration",level:3},{value:"Example 3: Balance-Aware Navigation Controller",id:"example-3-balance-aware-navigation-controller",level:3},{value:"Configuration Examples for Humanoid Navigation",id:"configuration-examples-for-humanoid-navigation",level:2},{value:"1. Complete Nav2 Configuration for Humanoid",id:"1-complete-nav2-configuration-for-humanoid",level:3},{value:"Troubleshooting Humanoid Navigation Issues",id:"troubleshooting-humanoid-navigation-issues",level:2},{value:"Common Navigation Problems and Solutions",id:"common-navigation-problems-and-solutions",level:3},{value:"1. Unstable Walking During Navigation",id:"1-unstable-walking-during-navigation",level:4},{value:"2. Footstep Planning Failures",id:"2-footstep-planning-failures",level:4},{value:"3. Localization Drift in Long-Term Navigation",id:"3-localization-drift-in-long-term-navigation",level:4},{value:"4. Turning Difficulties",id:"4-turning-difficulties",level:4},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:3},{value:"1. Computation Time Reduction",id:"1-computation-time-reduction",level:4},{value:"2. Balance Maintenance",id:"2-balance-maintenance",level:4},{value:"3. Energy Efficiency",id:"3-energy-efficiency",level:4},{value:"Exercises for Humanoid Navigation",id:"exercises-for-humanoid-navigation",level:2},{value:"Exercise 1: Basic Humanoid Navigation Setup",id:"exercise-1-basic-humanoid-navigation-setup",level:3},{value:"Exercise 2: Gait-Aware Path Planning",id:"exercise-2-gait-aware-path-planning",level:3},{value:"Exercise 3: Balance-Constrained Local Navigation",id:"exercise-3-balance-constrained-local-navigation",level:3},{value:"Exercise 4: Terrain-Aware Navigation",id:"exercise-4-terrain-aware-navigation",level:3},{value:"Exercise 5: Multi-Humanoid Coordination",id:"exercise-5-multi-humanoid-coordination",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"nav2-for-humanoid-navigation",children:"Nav2 for Humanoid Navigation"})}),"\n",(0,o.jsx)(e.p,{children:"This chapter covers the configuration and use of Navigation2 (Nav2) for humanoid robots, focusing on path planning and navigation workflows specifically adapted for bipedal locomotion. Unlike traditional wheeled robots, humanoid robots require specialized navigation strategies that account for their unique gait patterns, balance constraints, and mobility characteristics."}),"\n",(0,o.jsx)(e.h2,{id:"overview-of-nav2-for-humanoid-robots",children:"Overview of Nav2 for Humanoid Robots"}),"\n",(0,o.jsx)(e.p,{children:"Navigation2 (Nav2) is ROS 2's state-of-the-art navigation framework, but when applied to humanoid robots, it requires specialized configurations to accommodate the unique challenges of bipedal locomotion. Key considerations include:"}),"\n",(0,o.jsxs)(e.p,{children:["Nav2 for humanoid robots builds upon the navigation concepts from standard ROS 2 navigation, which are introduced in ",(0,o.jsx)(e.a,{href:"/docs/module-1/chapter-1-ros2-fundamentals",children:"Module 1: The Robotic Nervous System"}),". The humanoid-specific configurations leverage simulation environments that can be created following the principles in ",(0,o.jsx)(e.a,{href:"/docs/module-2/chapter-1-gazebo-basics",children:"Module 2: The Digital Twin"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"cross-module-connections",children:"Cross-Module Connections"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"With Module 1 (ROS 2)"}),": Nav2 extends the basic navigation concepts from ROS 2 with more sophisticated path planning and control algorithms. The action servers, costmaps, and other navigation components use the ROS 2 foundations you learned in Module 1."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"With Module 2 (Digital Twin)"}),": The navigation system can be developed and tested in simulated environments created in Gazebo or Unity before deployment to real humanoid robots, bridging simulation and reality."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Gait-aware path planning"}),": Accounting for humanoid walking patterns and stability"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Balance-constrained navigation"}),": Ensuring paths are traversable given balance limitations"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Footstep planning integration"}),": Coordinating navigation with footstep placement"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Dynamic stability"}),": Maintaining balance during navigation maneuvers"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-differences-from-wheeled-robot-navigation",children:"Key Differences from Wheeled Robot Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"mobility-constraints",children:"Mobility Constraints"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Turning mechanisms"}),": Humanoids turn by stepping rather than rotating in place"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Step size limitations"}),": Navigation must respect maximum step distances"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance recovery"}),": Ability to recover from minor disturbances during movement"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Terrain negotiation"}),": Capability to handle stairs, slopes, and uneven terrain differently"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"gait-patterns",children:"Gait Patterns"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Double support phase"}),": Periods where both feet contact the ground"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Single support phase"}),": Periods where only one foot contacts the ground"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Swing leg trajectory"}),": The path the moving foot takes during steps"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Zero Moment Point (ZMP) constraints"}),": Balance requirements during walking"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"nav2-architecture-for-humanoid-robots",children:"Nav2 Architecture for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.h4,{id:"1-global-planner-humanoid-aware",children:"1. Global Planner (Humanoid-Aware)"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Humanoid-optimized path planning"}),": Algorithms that consider humanoid kinematics"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gait pattern integration"}),": Path planning that accounts for walking patterns"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stability-aware optimization"}),": Ensuring paths are dynamically stable"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep planning coordination"}),": Integration with footstep planners"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"2-local-planner-balance-constrained",children:"2. Local Planner (Balance-Constrained)"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic window approach"}),": Adapted for humanoid balance constraints"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep-aware local planning"}),": Considering upcoming foot placements"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance recovery protocols"}),": Mechanisms to maintain stability during navigation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Reactive obstacle avoidance"}),": Adjusting gait patterns for obstacles"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"3-controller-gait-based",children:"3. Controller (Gait-Based)"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Walking pattern generators"}),": Controllers that generate appropriate gaits"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance maintenance"}),": Ensuring center of mass remains within stable regions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Step timing adaptation"}),": Adjusting step frequency and duration as needed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Transition management"}),": Smooth transitions between different walking modes"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-plugins",children:"Humanoid-Specific Plugins"}),"\n",(0,o.jsx)(e.h4,{id:"footstep-planner-plugin",children:"Footstep Planner Plugin"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"class HumanoidFootstepPlanner : public nav2_core::FootstepPlanner\n{\npublic:\n  void initialize(\n    const rclcpp_lifecycle::LifecycleNode::SharedPtr node,\n    const std::string & plugin_name) override;\n\n  std::vector<Footstep> planFootsteps(\n    const geometry_msgs::msg::PoseStamped & start,\n    const geometry_msgs::msg::PoseStamped & goal,\n    const nav_msgs::msg::OccupancyGrid & costmap) override;\n\nprivate:\n  double max_step_length_;\n  double max_step_width_;\n  double foot_separation_;\n};\n"})}),"\n",(0,o.jsx)(e.h4,{id:"balance-constraint-plugin",children:"Balance Constraint Plugin"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"class BalanceConstraintChecker : public nav2_core::ConstraintChecker\n{\npublic:\n  bool isTrajectoryValid(\n    const nav_msgs::msg::Path & path,\n    const nav_msgs::msg::OccupancyGrid & costmap) override;\n\n  bool isPoseBalanced(\n    const geometry_msgs::msg::Pose & pose) override;\n\nprivate:\n  double zmp_margin_;\n  double com_height_;\n  double max_lean_angle_;\n};\n"})}),"\n",(0,o.jsx)(e.h2,{id:"nav2-configuration-for-humanoid-navigation",children:"Nav2 Configuration for Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"global-planner-configuration",children:"Global Planner Configuration"}),"\n",(0,o.jsx)(e.h4,{id:"humanoid-optimized-global-planner-parameters",children:"Humanoid-Optimized Global Planner Parameters"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Global planner parameters for humanoid navigation\nglobal_planner:\n  ros__parameters:\n    # Basic parameters\n    expected_planner_frequency: 20.0\n    use_astar: false  # Use RRT* or other humanoid-appropriate algorithms\n    allow_unknown: false\n    tolerance: 0.5  # Increased tolerance for humanoid path following\n\n    # Humanoid-specific parameters\n    min_turn_radius: 0.3  # Minimum turning radius considering step constraints\n    max_step_length: 0.6  # Maximum distance between consecutive footsteps\n    max_step_width: 0.4   # Maximum lateral step distance\n    gait_pattern: "natural_walk"  # Type of walking pattern to assume\n\n    # Balance constraints\n    zmp_margin: 0.05      # Zero Moment Point safety margin\n    com_height: 0.8       # Center of Mass height for stability\n    max_lean_angle: 15.0  # Maximum acceptable lean angle in degrees\n'})}),"\n",(0,o.jsx)(e.h3,{id:"local-planner-configuration",children:"Local Planner Configuration"}),"\n",(0,o.jsx)(e.h4,{id:"dwb-dynamic-window-approach-for-humanoid-robots",children:"DWB (Dynamic Window Approach) for Humanoid Robots"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# Local planner configuration for humanoid navigation\nlocal_planner:\n  ros__parameters:\n    # Basic DWB parameters\n    desired_linear_vel: 0.3\n    max_linear_vel: 0.5\n    min_linear_vel: 0.1\n    max_angular_vel: 0.5\n    min_angular_vel: 0.1\n\n    # Humanoid-specific parameters\n    max_translational_accel: 0.5   # Lower acceleration for balance\n    max_translational_decel: 1.0   # Higher deceleration for stopping\n    max_rotational_vel: 0.3       # Slower turns for stability\n    min_rotational_vel: 0.05      # Minimum rotation for fine adjustments\n\n    # Balance-related parameters\n    com_safety_margin: 0.1        # Safety margin for center of mass\n    step_timing_tolerance: 0.2     # Tolerance for step timing\n    balance_recovery_threshold: 0.8 # Threshold for balance recovery mode\n\n    # Footstep planning integration\n    footstep_lookahead: 5         # Number of future footsteps to consider\n    step_duration: 0.8            # Expected duration of each step\n"})}),"\n",(0,o.jsx)(e.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,o.jsx)(e.h4,{id:"humanoid-aware-costmaps",children:"Humanoid-Aware Costmaps"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Costmap configuration for humanoid navigation\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      width: 20\n      height: 20\n      resolution: 0.05\n      origin_x: -10.0\n      origin_y: -10.0\n\n      # Humanoid-specific inflation\n      plugins: ["static_layer", "obstacle_layer", "voxel_layer", "inflation_layer"]\n\n      inflation_layer:\n        cost_scaling_factor: 1.5    # Adjusted for humanoid safety\n        inflation_radius: 0.8       # Larger safety radius for bipedal stability\n        inflate_unknown: false\n\n      voxel_layer:\n        enabled: true\n        voxel_size: 0.2             # Appropriate for humanoid-sized obstacles\n        max_obstacle_height: 2.0    # Humanoid can step over small obstacles\n        observation_sources: scan\n        scan:\n          topic: /laser_scan\n          max_obstacle_height: 2.0\n          clearing: true\n          marking: true\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 10.0\n      publish_frequency: 5.0\n      width: 6\n      height: 6\n      resolution: 0.05\n      origin_x: -3.0\n      origin_y: -3.0\n\n      # Humanoid-specific local costmap\n      plugins: ["obstacle_layer", "voxel_layer", "inflation_layer"]\n\n      inflation_layer:\n        cost_scaling_factor: 3.0    # Higher scaling for local safety\n        inflation_radius: 0.6       # Local inflation for immediate safety\n'})}),"\n",(0,o.jsx)(e.h2,{id:"practical-examples-humanoid-navigation-scenarios",children:"Practical Examples: Humanoid Navigation Scenarios"}),"\n",(0,o.jsx)(e.h3,{id:"example-1-basic-humanoid-navigation-setup",children:"Example 1: Basic Humanoid Navigation Setup"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Basic humanoid navigation setup using Nav2\n\nimport rclpy\nfrom rclpy.node import Node\nfrom nav2_simple_commander.robot_navigator import BasicNavigator\nfrom geometry_msgs.msg import PoseStamped\nfrom builtin_interfaces.msg import Duration\nimport math\n\nclass HumanoidNavigator(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_navigator\')\n\n        # Initialize the navigator\n        self.navigator = BasicNavigator()\n\n        # Wait for Nav2 to activate\n        self.navigator.waitUntilNav2Active(localizer=\'amcl\')\n\n        # Set robot-specific parameters\n        self.step_length = 0.5  # meters\n        self.max_turn_radius = 0.3  # meters\n        self.balance_threshold = 0.8  # balance factor\n\n        self.get_logger().info("Humanoid Navigator initialized")\n\n    def create_pose_stamped(self, position_x, position_y, orientation_z, orientation_w):\n        """Create a PoseStamped message"""\n        pose = PoseStamped()\n        pose.header.frame_id = \'map\'\n        pose.header.stamp = self.get_clock().now().to_msg()\n        pose.pose.position.x = position_x\n        pose.pose.position.y = position_y\n        pose.pose.position.z = 0.0\n        pose.pose.orientation.x = 0.0\n        pose.pose.orientation.y = 0.0\n        pose.pose.orientation.z = orientation_z\n        pose.pose.orientation.w = orientation_w\n        return pose\n\n    def navigate_with_gait_constraints(self, goal_pose):\n        """Navigate to goal with humanoid-specific constraints"""\n\n        # Pre-process the goal to ensure it\'s reachable with humanoid gait\n        adjusted_goal = self.adjust_goal_for_humanoid(goal_pose)\n\n        # Send the goal to Nav2\n        self.navigator.goToPose(adjusted_goal)\n\n        # Monitor progress with balance awareness\n        while not self.navigator.isTaskComplete():\n            # Get feedback on navigation progress\n            feedback = self.navigator.getFeedback()\n\n            # Check balance constraints during navigation\n            if self.check_balance_constraint():\n                # Continue navigation\n                pass\n            else:\n                # Trigger balance recovery\n                self.trigger_balance_recovery()\n\n        # Get result\n        result = self.navigator.getResult()\n        return result\n\n    def adjust_goal_for_humanoid(self, original_goal):\n        """Adjust goal pose to be achievable with humanoid gait"""\n        adjusted_goal = original_goal\n\n        # Ensure goal is not too close to obstacles considering humanoid size\n        # Humanoids need more space to maneuver than wheeled robots\n        min_clearance = 0.6  # meters\n\n        # Additional adjustments based on humanoid kinematics\n        # Could include checking if the final pose allows for proper foot placement\n\n        return adjusted_goal\n\n    def check_balance_constraint(self):\n        """Check if current navigation state maintains balance"""\n        # This would typically interface with balance controller\n        # For simulation, we\'ll return True\n        return True\n\n    def trigger_balance_recovery(self):\n        """Trigger balance recovery mechanism"""\n        self.get_logger().warn("Balance recovery triggered!")\n        # Implement balance recovery logic\n        # This might involve stopping, adjusting stance, etc.\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    navigator = HumanoidNavigator()\n\n    # Define a goal\n    goal_pose = navigator.create_pose_stamped(\n        position_x=2.0,\n        position_y=2.0,\n        orientation_z=0.0,\n        orientation_w=1.0\n    )\n\n    try:\n        # Navigate to goal with humanoid constraints\n        result = navigator.navigate_with_gait_constraints(goal_pose)\n\n        if result:\n            navigator.get_logger().info("Goal reached successfully!")\n        else:\n            navigator.get_logger().info("Failed to reach goal.")\n\n    except KeyboardInterrupt:\n        pass\n    finally:\n        navigator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-humanoid-footstep-planning-integration",children:"Example 2: Humanoid Footstep Planning Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Humanoid footstep planning integration with Nav2\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom visualization_msgs.msg import Marker, MarkerArray\nfrom std_msgs.msg import ColorRGBA\nimport numpy as np\n\nclass HumanoidFootstepPlanner(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_footstep_planner\')\n\n        # Publishers for visualization\n        self.footstep_marker_pub = self.create_publisher(MarkerArray, \'humanoid_footsteps\', 10)\n        self.footstep_plan_pub = self.create_publisher(MarkerArray, \'footstep_plan\', 10)\n\n        # Parameters\n        self.foot_separation = 0.3  # Distance between feet when standing\n        self.max_step_length = 0.6  # Maximum step forward\n        self.max_step_width = 0.4   # Maximum lateral step\n        self.step_height = 0.1      # Height of foot during swing phase\n\n        self.get_logger().info("Humanoid Footstep Planner initialized")\n\n    def plan_footsteps(self, start_pose, goal_pose, path):\n        """Plan footsteps for humanoid navigation along a path"""\n\n        footsteps = []\n\n        # Convert path poses to footsteps\n        for i in range(len(path.poses)):\n            # Determine if this should be a left or right footstep\n            is_left_foot = (i % 2) == 0  # Alternate feet\n\n            # Create footstep pose\n            foot_pose = self.calculate_foot_pose(\n                path.poses[i],\n                is_left_foot,\n                self.foot_separation\n            )\n\n            footsteps.append({\n                \'pose\': foot_pose,\n                \'is_left\': is_left_foot,\n                \'step_number\': i\n            })\n\n        return footsteps\n\n    def calculate_foot_pose(self, body_pose, is_left_foot, foot_separation):\n        """Calculate foot pose based on body pose and which foot"""\n\n        foot_pose = PoseStamped()\n        foot_pose.header = body_pose.header\n\n        # Calculate foot offset based on which foot and body orientation\n        yaw = self.quaternion_to_yaw(body_pose.pose.orientation)\n\n        # Left foot offset (positive Y) or right foot offset (negative Y)\n        if is_left_foot:\n            lateral_offset = foot_separation / 2.0\n        else:\n            lateral_offset = -foot_separation / 2.0\n\n        # Apply rotation to get the actual offset in map frame\n        offset_x = -lateral_offset * math.sin(yaw)\n        offset_y = lateral_offset * math.cos(yaw)\n\n        foot_pose.pose.position.x = body_pose.pose.position.x + offset_x\n        foot_pose.pose.position.y = body_pose.pose.position.y + offset_y\n        foot_pose.pose.position.z = 0.0  # On ground\n\n        # Foot orientation matches body orientation\n        foot_pose.pose.orientation = body_pose.pose.orientation\n\n        return foot_pose\n\n    def quaternion_to_yaw(self, quat):\n        """Convert quaternion to yaw angle"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def visualize_footsteps(self, footsteps):\n        """Publish visualization markers for footsteps"""\n\n        marker_array = MarkerArray()\n\n        for i, footstep in enumerate(footsteps):\n            marker = Marker()\n            marker.header.frame_id = "map"\n            marker.header.stamp = self.get_clock().now().to_msg()\n            marker.ns = "footsteps"\n            marker.id = i\n            marker.type = Marker.CYLINDER\n            marker.action = Marker.ADD\n\n            # Position\n            marker.pose = footstep[\'pose\'].pose\n\n            # Scale (foot size)\n            marker.scale.x = 0.15  # Diameter\n            marker.scale.y = 0.15  # Diameter\n            marker.scale.z = 0.01  # Thickness\n\n            # Color based on foot type\n            if footstep[\'is_left\']:\n                marker.color = ColorRGBA(r=0.0, g=0.0, b=1.0, a=0.8)  # Blue for left\n            else:\n                marker.color = ColorRGBA(r=1.0, g=0.0, b=0.0, a=0.8)  # Red for right\n\n            marker_array.markers.append(marker)\n\n        self.footstep_marker_pub.publish(marker_array)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    footstep_planner = HumanoidFootstepPlanner()\n\n    try:\n        rclpy.spin(footstep_planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        footstep_planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"example-3-balance-aware-navigation-controller",children:"Example 3: Balance-Aware Navigation Controller"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Balance-aware navigation controller for humanoid robots\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Point\nfrom sensor_msgs.msg import Imu\nfrom tf2_ros import TransformListener, Buffer\nfrom std_msgs.msg import Float64\nimport numpy as np\nimport math\n\nclass HumanoidBalanceController(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_balance_controller\')\n\n        # Subscribers\n        self.cmd_vel_sub = self.create_subscription(Twist, \'cmd_vel_input\', self.cmd_vel_callback, 10)\n        self.imu_sub = self.create_subscription(Imu, \'/imu/data\', self.imu_callback, 10)\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel_output\', 10)\n        self.balance_status_pub = self.create_publisher(Float64, \'balance_status\', 10)\n\n        # TF listener for pose information\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Balance parameters\n        self.com_height = 0.8  # Center of mass height\n        self.zmp_margin = 0.05  # ZMP safety margin\n        self.balance_threshold = 0.7  # Balance factor threshold\n        self.recovery_gain = 2.0  # Recovery gain for balance correction\n\n        # State variables\n        self.current_roll = 0.0\n        self.current_pitch = 0.0\n        self.current_yaw = 0.0\n        self.balance_factor = 1.0  # 1.0 = perfectly balanced, 0.0 = fallen\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.05, self.balance_control_loop)  # 20Hz\n\n        self.get_logger().info("Humanoid Balance Controller initialized")\n\n    def imu_callback(self, msg):\n        """Process IMU data to determine balance state"""\n\n        # Convert quaternion to Euler angles\n        orientation = msg.orientation\n        self.current_roll, self.current_pitch, self.current_yaw = self.quaternion_to_euler(\n            orientation.x, orientation.y, orientation.z, orientation.w\n        )\n\n        # Calculate balance factor based on tilt angles\n        roll_contribution = abs(self.current_roll) / (math.pi / 6)  # Assuming max stable roll is 30 degrees\n        pitch_contribution = abs(self.current_pitch) / (math.pi / 6)  # Same for pitch\n\n        # Balance factor decreases as tilt increases (1.0 = perfect balance, 0.0 = unstable)\n        self.balance_factor = max(0.0, 1.0 - (roll_contribution + pitch_contribution) / 2.0)\n\n        # Publish balance status\n        balance_msg = Float64()\n        balance_msg.data = self.balance_factor\n        self.balance_status_pub.publish(balance_msg)\n\n    def cmd_vel_callback(self, msg):\n        """Receive velocity commands and apply balance constraints"""\n\n        # Store the desired velocity for the control loop\n        self.desired_linear_x = msg.linear.x\n        self.desired_angular_z = msg.angular.z\n\n    def balance_control_loop(self):\n        """Main balance control loop"""\n\n        # Create output twist message\n        output_twist = Twist()\n\n        # Check current balance state\n        if self.balance_factor < self.balance_threshold:\n            # Robot is becoming unbalanced, apply recovery measures\n            self.get_logger().warn(f"Balance factor low: {self.balance_factor:.2f}, applying recovery")\n\n            # Reduce commanded velocities to help recover balance\n            output_twist.linear.x = self.desired_linear_x * self.balance_factor * self.recovery_gain\n            output_twist.angular.z = self.desired_angular_z * self.balance_factor * self.recovery_gain\n\n            # Optionally add corrective motions to restore balance\n            self.apply_balance_correction(output_twist)\n        else:\n            # Robot is well balanced, use commanded velocities with safety limits\n            output_twist.linear.x = self.limit_velocity(\n                self.desired_linear_x,\n                max_vel=0.5,  # Lower max velocity for humanoid safety\n                balance_factor=self.balance_factor\n            )\n\n            output_twist.angular.z = self.limit_velocity(\n                self.desired_angular_z,\n                max_vel=0.3,\n                balance_factor=self.balance_factor\n            )\n\n        # Publish the controlled velocity command\n        self.cmd_vel_pub.publish(output_twist)\n\n    def apply_balance_correction(self, twist_msg):\n        """Apply corrective motions to improve balance"""\n\n        # Simple proportional correction based on tilt\n        # This would be more sophisticated in a real implementation\n        correction_factor = (self.balance_threshold - self.balance_factor) * 5.0\n\n        # Apply linear correction to counteract tilt\n        if abs(self.current_roll) > 0.1:  # If tilted significantly in roll\n            twist_msg.linear.y += -np.sign(self.current_roll) * correction_factor * 0.1\n\n        if abs(self.current_pitch) > 0.1:  # If tilted significantly in pitch\n            twist_msg.linear.x += -np.sign(self.current_pitch) * correction_factor * 0.1\n\n    def limit_velocity(self, desired_vel, max_vel, balance_factor):\n        """Limit velocity based on balance factor"""\n        limited_vel = max(-max_vel, min(max_vel, desired_vel))\n\n        # Scale by balance factor for safety\n        return limited_vel * balance_factor\n\n    def quaternion_to_euler(self, x, y, z, w):\n        """Convert quaternion to Euler angles (roll, pitch, yaw)"""\n        # Roll (x-axis rotation)\n        sinr_cosp = 2 * (w * x + y * z)\n        cosr_cosp = 1 - 2 * (x * x + y * y)\n        roll = math.atan2(sinr_cosp, cosr_cosp)\n\n        # Pitch (y-axis rotation)\n        sinp = 2 * (w * y - z * x)\n        pitch = math.asin(sinp)\n\n        # Yaw (z-axis rotation)\n        siny_cosp = 2 * (w * z + x * y)\n        cosy_cosp = 1 - 2 * (y * y + z * z)\n        yaw = math.atan2(siny_cosp, cosy_cosp)\n\n        return roll, pitch, yaw\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    balance_controller = HumanoidBalanceController()\n\n    try:\n        rclpy.spin(balance_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        balance_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"configuration-examples-for-humanoid-navigation",children:"Configuration Examples for Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"1-complete-nav2-configuration-for-humanoid",children:"1. Complete Nav2 Configuration for Humanoid"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# main_nav2_humanoid_config.yaml\n\namcl:\n  ros__parameters:\n    use_sim_time: False\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_delay: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    global_frame: "map"\n    robot_base_frame: "base_link"\n    odom_topic: "odom"\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Humanoid-specific BT configuration\n    default_nav_through_poses_bt_xml: "humanoid_nav_through_poses_w_replanning_and_recovery.xml"\n    default_nav_to_pose_bt_xml: "humanoid_nav_to_pose_w_replanning_and_recovery.xml"\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_costmap_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_single_trigger_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n    - nav2_remove_passed_goals_action_bt_node\n    - nav2_planner_selector_bt_node\n    - nav2_controller_selector_bt_node\n    - nav2_goal_checker_selector_bt_node\n    - nav2_controller_cancel_bt_node\n    - nav2_path_longer_on_approach_bt_node\n    - nav2_wait_cancel_bt_node\n    - nav2_spin_cancel_bt_node\n    - nav2_back_up_cancel_bt_node\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: False\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.05\n    min_y_velocity_threshold: 0.1\n    min_theta_velocity_threshold: 0.1\n    # Humanoid-specific controllers\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["HumanoidMpcController"]  # Humanoid-specific controller\n\n    HumanoidMpcController:\n      plugin: "nav2_mppi_controller::Controller"\n      time_steps: 26\n      dt: 0.1\n      horizon: 2.5\n      # Humanoid-specific MPC parameters\n      discretization_method: "midpoint"\n      iteration_count: 3\n      enable_antialiasing: false\n      model_predictive_path_integral:\n        transform_tolerance: 0.2\n        frequency: 20.0\n        xy_goal_tolerance: 0.25\n        trans_stopped_velocity: 0.25\n        theta_goal_tolerance: 0.4\n        rot_stopped_velocity: 0.5\n        n_workers: 3\n        regularization_lambda: 0.0\n        motion_model: "Ackermann"\n        weight:\n          goal_distance: 1.0\n          path_distance: 2.0\n          goal_angle: 0.5\n          path_angle: 0.2\n          obstacle: 5.0\n          dynamic_obstacle: 10.0\n          constraint: 100.0\n          goal_angle_current_pose: 0.0\n        noise:\n          model_type: "Mixed"\n          theta: 0.5\n          vx_std: 0.2\n          vy_std: 0.0\n          omega_std: 0.3\n          vtheta_mean: 0.0\n          vtheta_std: 0.1\n        ackermann:\n          min_turning_r: 0.3  # Humanoid-specific turning radius\n          max_steering_angle: 0.5\n          max_longitudinal_acc: 0.5  # Reduced for balance\n          min_longitudinal_acc: -1.0\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 10.0\n      publish_frequency: 5.0\n      global_frame: "odom"\n      robot_base_frame: "base_link"\n      use_sim_time: False\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05\n      # Humanoid-specific parameters\n      robot_radius: 0.4  # Larger radius for humanoid safety\n      plugins: ["obstacle_layer", "voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.6\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: "/scan"\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: pointcloud\n        pointcloud:\n          topic: "/pointcloud"\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "PointCloud2"\n          min_obstacle_height: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.1\n          raytrace_max_range: 3.0\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: "map"\n      robot_base_frame: "base_link"\n      use_sim_time: False\n      robot_radius: 0.4  # Humanoid-specific radius\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 1.5\n        inflation_radius: 0.8\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: "/scan"\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 10.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 10.0\n          obstacle_min_range: 0.0\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: pointcloud\n        pointcloud:\n          topic: "/pointcloud"\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "PointCloud2"\n          min_obstacle_height: 0.0\n          obstacle_max_range: 10.0\n          obstacle_min_range: 0.1\n          raytrace_max_range: 10.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: False\n    planner_plugins: ["GridBased"]\n    GridBased:\n      # Use a planner appropriate for humanoid navigation\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: false\n      # Humanoid-specific parameters\n      max_step_length: 0.6  # Maximum distance between waypoints\n      max_deviation: 0.3    # Maximum deviation from straight line\n\nsmoother_server:\n  ros__parameters:\n    use_sim_time: False\n    smoother_plugins: ["simple_smoother"]\n    simple_smoother:\n      plugin: "nav2_smoother::SimpleSmoother"\n      tolerance: 1.0e-10\n      max_its: 1000\n      do_refinement: True\n      # Humanoid-specific smoothing parameters\n      smooth_weight: 0.05   # Less aggressive smoothing for precise footstep planning\n      curvature_weight: 0.2 # Balance between smoothness and curvature\n      smooth_scale: 1.0\n\nbehavior_server:\n  ros__parameters:\n    costmap_topic: "local_costmap/costmap_raw"\n    footprint_topic: "local_costmap/published_footprint"\n    cycle_frequency: 10.0\n    behavior_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_behaviors::Spin"\n      # Humanoid-specific spin parameters\n      spin_dist: 0.5  # Reduced spin distance for humanoid\n      time_allowance: 10\n    backup:\n      plugin: "nav2_behaviors::BackUp"\n      # Humanoid-specific backup parameters\n      backup_dist: 0.3  # Shorter backup distance\n      backup_speed: 0.1\n      time_allowance: 10\n    wait:\n      plugin: "nav2_behaviors::Wait"\n      time_allowance: 10\n'})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-humanoid-navigation-issues",children:"Troubleshooting Humanoid Navigation Issues"}),"\n",(0,o.jsx)(e.h3,{id:"common-navigation-problems-and-solutions",children:"Common Navigation Problems and Solutions"}),"\n",(0,o.jsx)(e.h4,{id:"1-unstable-walking-during-navigation",children:"1. Unstable Walking During Navigation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot becomes unstable or falls during navigation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Causes"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Velocity commands too aggressive for balance"}),"\n",(0,o.jsx)(e.li,{children:"Poor ZMP (Zero Moment Point) management"}),"\n",(0,o.jsx)(e.li,{children:"Inadequate feedback control"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce maximum linear and angular velocities"}),"\n",(0,o.jsx)(e.li,{children:"Implement balance feedback control"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate gait patterns for commanded speeds"}),"\n",(0,o.jsx)(e.li,{children:"Add safety margins to navigation parameters"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"2-footstep-planning-failures",children:"2. Footstep Planning Failures"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot cannot find valid footsteps to reach goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Causes"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Overly constrained footstep planning"}),"\n",(0,o.jsx)(e.li,{children:"Obstacles too close to navigable path"}),"\n",(0,o.jsx)(e.li,{children:"Inaccurate robot dimensions in configuration"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjust step length and width constraints"}),"\n",(0,o.jsx)(e.li,{children:"Improve costmap resolution for footstep planning"}),"\n",(0,o.jsx)(e.li,{children:"Implement step recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Use more flexible footstep planning algorithms"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"3-localization-drift-in-long-term-navigation",children:"3. Localization Drift in Long-Term Navigation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot loses accurate position estimate over time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Causes"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Accumulated odometry errors from walking"}),"\n",(0,o.jsx)(e.li,{children:"Limited sensing capabilities during bipedal locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Uneven terrain affecting sensor readings"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Enhance localization with multiple sensors (IMU, cameras, LIDAR)"}),"\n",(0,o.jsx)(e.li,{children:"Implement loop closure detection"}),"\n",(0,o.jsx)(e.li,{children:"Use visual-inertial odometry for better accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Regular map-based relocalization"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"4-turning-difficulties",children:"4. Turning Difficulties"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot struggles to execute turns properly"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Causes"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Turning radius too tight for humanoid kinematics"}),"\n",(0,o.jsx)(e.li,{children:"Inadequate balance control during turns"}),"\n",(0,o.jsx)(e.li,{children:"Poor coordination between steps during rotation"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Increase minimum turning radius in configuration"}),"\n",(0,o.jsx)(e.li,{children:"Implement specialized turning gaits"}),"\n",(0,o.jsx)(e.li,{children:"Use step-and-turn sequences rather than in-place rotation"}),"\n",(0,o.jsx)(e.li,{children:"Add balance control during turning maneuvers"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,o.jsx)(e.h4,{id:"1-computation-time-reduction",children:"1. Computation Time Reduction"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Efficient path planning"}),": Use hierarchical planning with coarse global and fine local planners"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parallel processing"}),": Execute perception, planning, and control in parallel threads"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Predictive planning"}),": Precompute potential paths based on likely goals"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"2-balance-maintenance",children:"2. Balance Maintenance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Proactive balance control"}),": Anticipate balance challenges and adjust gait accordingly"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Adaptive step timing"}),": Modify step duration based on terrain and obstacle requirements"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery strategies"}),": Implement graceful recovery from near-fall situations"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"3-energy-efficiency",children:"3. Energy Efficiency"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Optimal gait selection"}),": Choose energy-efficient walking patterns"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Smooth transitions"}),": Minimize energy waste during direction changes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Terrain adaptation"}),": Adjust gait for different surface types"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"exercises-for-humanoid-navigation",children:"Exercises for Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"exercise-1-basic-humanoid-navigation-setup",children:"Exercise 1: Basic Humanoid Navigation Setup"}),"\n",(0,o.jsx)(e.p,{children:"Configure Nav2 for basic humanoid navigation in a simple environment."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Requirements:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Set up Nav2 with humanoid-appropriate parameters"}),"\n",(0,o.jsx)(e.li,{children:"Configure costmaps for humanoid dimensions"}),"\n",(0,o.jsx)(e.li,{children:"Test basic navigation in a simple environment"}),"\n",(0,o.jsx)(e.li,{children:"Verify balance-aware velocity control"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Steps:"})}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Install Nav2 packages for humanoid navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configure robot-specific parameters (dimensions, step size, etc.)"}),"\n",(0,o.jsx)(e.li,{children:"Set up localization (AMCL) for humanoid robot"}),"\n",(0,o.jsx)(e.li,{children:"Test navigation in gazebo simulation"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate performance metrics (success rate, time to goal, balance maintenance)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-2-gait-aware-path-planning",children:"Exercise 2: Gait-Aware Path Planning"}),"\n",(0,o.jsx)(e.p,{children:"Implement and test gait-aware path planning for humanoid robots."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Requirements:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Configure path planner with humanoid kinematic constraints"}),"\n",(0,o.jsx)(e.li,{children:"Implement footstep planning integration"}),"\n",(0,o.jsx)(e.li,{children:"Test path feasibility with actual walking patterns"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate path optimality considering gait requirements"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Implementation:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Modify global planner to consider humanoid step constraints"}),"\n",(0,o.jsx)(e.li,{children:"Integrate with footstep planner"}),"\n",(0,o.jsx)(e.li,{children:"Validate paths with kinematic simulation"}),"\n",(0,o.jsx)(e.li,{children:"Compare with traditional wheeled robot planning"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-3-balance-constrained-local-navigation",children:"Exercise 3: Balance-Constrained Local Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Implement local navigation with balance constraints for humanoid robots."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Requirements:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Develop balance-aware local planner"}),"\n",(0,o.jsx)(e.li,{children:"Integrate IMU feedback for real-time balance adjustment"}),"\n",(0,o.jsx)(e.li,{children:"Test obstacle avoidance while maintaining stability"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate balance recovery behaviors"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Components:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Balance monitoring system"}),"\n",(0,o.jsx)(e.li,{children:"Velocity limiting based on stability"}),"\n",(0,o.jsx)(e.li,{children:"Reactive obstacle avoidance with balance preservation"}),"\n",(0,o.jsx)(e.li,{children:"Recovery behaviors for near-instability situations"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-4-terrain-aware-navigation",children:"Exercise 4: Terrain-Aware Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Extend navigation system to handle varied terrain types."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Requirements:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adapt navigation for stairs, slopes, and uneven terrain"}),"\n",(0,o.jsx)(e.li,{children:"Implement terrain classification and gait selection"}),"\n",(0,o.jsx)(e.li,{children:"Test navigation on challenging terrain"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate robustness and safety"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Features:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Terrain type detection"}),"\n",(0,o.jsx)(e.li,{children:"Gait pattern selection based on terrain"}),"\n",(0,o.jsx)(e.li,{children:"Adjusted navigation parameters per terrain type"}),"\n",(0,o.jsx)(e.li,{children:"Safe transition between different terrains"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-5-multi-humanoid-coordination",children:"Exercise 5: Multi-Humanoid Coordination"}),"\n",(0,o.jsx)(e.p,{children:"Implement coordinated navigation for multiple humanoid robots."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Requirements:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Extend navigation system for multi-robot scenarios"}),"\n",(0,o.jsx)(e.li,{children:"Implement collision avoidance between humanoids"}),"\n",(0,o.jsx)(e.li,{children:"Test formation navigation"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate scalability and communication requirements"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Challenges:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Inter-humanoid collision avoidance"}),"\n",(0,o.jsx)(e.li,{children:"Communication-limited coordination"}),"\n",(0,o.jsx)(e.li,{children:"Formation maintenance during navigation"}),"\n",(0,o.jsx)(e.li,{children:"Scalability to larger groups"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 for humanoid navigation requires specialized configurations that account for the unique challenges of bipedal locomotion. Unlike wheeled robots, humanoids must consider balance constraints, gait patterns, and footstep planning during navigation. Successful implementation requires careful tuning of parameters, integration with balance control systems, and specialized planning algorithms that respect the kinematic and dynamic constraints of bipedal walking. With proper configuration, Nav2 can enable capable and safe navigation for humanoid robots in various environments."}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Explore related topics in Module 3:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.a,{href:"/docs/module-3/chapter-1-isaac-sim-essentials",children:"Chapter 1: Isaac Sim Essentials"})," - Simulation fundamentals for training"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.a,{href:"/docs/module-3/chapter-2-isaac-ros-integration",children:"Chapter 2: Isaac ROS Integration"})," - Perception and integration concepts"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Or explore other modules:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.a,{href:"/docs/module-1/chapter-1-ros2-fundamentals",children:"Module 1: The Robotic Nervous System (ROS 2)"})," - Fundamentals of ROS 2"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.a,{href:"/docs/module-2/chapter-1-gazebo-basics",children:"Module 2: The Digital Twin (Gazebo & Unity)"})," - Simulation and interaction concepts"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,e,a){a.d(e,{R:()=>r,x:()=>s});var i=a(6540);const o={},t=i.createContext(o);function r(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);